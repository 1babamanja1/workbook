//WeakMap и WeakSet

//WeakMap
//Ключи не могут быть примитивами
//Если кроме как в WeakMap ссылок на объект нет, то он удалится сборщиком мусора:

let weakObj = {name: "Bella"};
let newWeakMap = new WeakMap();
newWeakMap.set(weakObj, "value");
// console.log(newWeakMap.get(weakObj)); //value
weakObj = null;
// console.log(newWeakMap.get(weakObj)); //undefined

let obj = {name: "Dora"};
let newMap2 = new Map();
// console.log(newMap2.size); //0
newMap2.set(obj, "val");
// console.log(newMap2.size); //1
obj = null;
// console.log(newMap2.size); //1
//Непон.

//WeakMap нельзя перебрать, потому что неизвестно, собран уже муор или нет и точное количество элементов жс не знает

//WeakSet охож на Set, но добавлять можно только НЕпримитивы
//Тоже не перебирается и нельзя посмотреть длину

//Задача 1:

//Есть массив сообщений:

let messages = [
    {text: "Hello", from: "John"},
    {text: "How goes?", from: "John"},
    {text: "See you soon", from: "Alice"},
];

//У вас есть к ним доступ, но управление этим массивом происходит где-то ещё. Добавляются новые сообщения и удаляются старые, и вы не знаете в какой момент это может произойти.
// Имея такую вводную информацию, решите, какую структуру данных вы могли бы использовать для ответа на вопрос «было ли сообщение прочитано?». Структура должна быть подходящей, чтобы можно было однозначно сказать, было ли прочитано это сообщение для каждого объекта сообщения.
// P.S. Когда сообщение удаляется из массива messages, оно должно также исчезать из структуры данных.
// P.P.S. Нам не следует модифицировать сами объекты сообщений, добавлять туда свойства. Если сообщения принадлежат какому-то другому коду, то это может привести к плохим последствиям.

//Хорошо использовать сет, т.к если мыпрочитаем сообщени 2 раза, оно не добавится ещё раз
let readMessages = new WeakSet();
readMessages.add(messages[2]); //если сообщение прочитано
// console.log(readMessages.has(messages[2])); // true

delete messages[2];
// console.log(readMessages.has(messages[2])); //false

//Задача 2:
//Есть массив сообщений такой же, как и в предыдущем задании.
//Теперь вопрос стоит так: какую структуру данных вы бы предложили использовать для хранения информации о том, когда сообщение было прочитано?
// В предыдущем задании нам нужно было сохранить только факт прочтения «да или нет». Теперь же нам нужно сохранить дату, и она должна исчезнуть из памяти при удалении «сборщиком мусора» сообщения.

let readingTime = new WeakMap(); //здесь по идее важно, когда было прочитано сообщение, даже если его читали несколько раз
readingTime.set(messages[0], new Date(2020, 11, 21));
